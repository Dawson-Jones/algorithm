## 进程

### 虚拟内存

> 绝对地址: 进程之间数据不隔离, 若不注意, 内存会互相覆盖
>
> 虚拟地址: 进入保护模式, 用来隔离进程, 对进程来说透明, 更加安全

操作系统会提供一种机制, 将不通进程的**虚拟地址**和不同内存的**物理地址**映射起来(通过MMU memory manage unit)

#### 内存分段(cpu 也有分段的概念, 但那是因为**寄存器CS:IP**造成的)

通过**段选择子**和**段内偏移量**找到真实内存

**优点**: 

1. 解决了虚拟内存映射问题

**缺点**: 

1. 内存碎片
2. 内存交互效率低

分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。

![内存分段](/Users/dawson/project/my_project/C/algorithm/img/v2-1d41ca6712224fc7ee0226875c59336a_r.jpeg)



#### 内存分页

通过**页号**和**页内偏移**找到真实内存

1. **分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。
2. 虚拟地址与物理地址之间通过**页表**(MMU)来映射
3. **采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。**

**优点**: 

1. 释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。
2. 内存可以不连续
3. 不再需要一次性都把程序加载到物理内存中

问题: 页表会非常的庞大

解决: **多级页表**



### 僵尸进程

**僵尸进程**是指完成执行（通过`exit`[系统调用](https://zh.wikipedia.org/wiki/系统调用)，或运行时发生[致命错误](https://zh.wikipedia.org/wiki/致命错误)或收到终止[信号](https://zh.wikipedia.org/wiki/信号_(计算机科学))所致），但在操作系统的**进程表**中仍然存在其[进程控制块](https://zh.wikipedia.org/wiki/进程控制块)，处于"[终止状态](https://zh.wikipedia.org/w/index.php?title=终止状态&action=edit&redlink=1)"的进程。

[子进程](https://zh.wikipedia.org/wiki/子进程)需要保留表项以允许其[父进程](https://zh.wikipedia.org/wiki/父进程)读取子进程的[退出状态](https://zh.wikipedia.org/wiki/退出状态)：一旦退出态通过`wait`[系统调用](https://zh.wikipedia.org/wiki/系统调用)读取，僵尸进程条目就从进程表中删除，称之为"回收"（reaped）。

#### 避免产生僵尸进程

1. 将父进程中对 SIGCHLD 信号的处理函数设为 SIG_IGN（忽略信号）；
2. fork两次并杀死一级子进程，令二级子进程成为孤儿进程而被init所“收养”、清理

### [孤儿进程](https://zh.wikipedia.org/wiki/孤儿进程)

不同于僵尸进程，其父进程已经死掉，但孤儿进程仍能正常执行，但并不会变为僵尸进程，因为被`init`（进程ID号为1）收养并`wait`其退出。



### 进程切换发生了什么

1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。



### IPC





## 网络

### IO多路复用

- IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；
- 一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；
- 没有文件句柄就绪就会阻塞应用程序，交出CPU。

>  多路是指网络连接，复用指的是同一个线程

没有IO多路复用机制时，有BIO、NIO两种实现方式

#### 同步阻塞（BIO）

- 服务端采用单线程，当 `accept` 一个请求后，在 `recv` 或 `send` 调用阻塞时，将无法 `accept` 其他请求（必须等上一个请求处理 `recv` 或 `send` 完 ）（无法处理并发）

#### 同步非阻塞（NIO）

- 服务器端当 `accept` 一个请求后，加入 `fds` 集合，每次轮询一遍 `fds` 集合 `recv` (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU。

#### select缺点

- 单个进程所打开的FD是有限制的，通过 `FD_SETSIZE` 设置，默认1024 ;
- 对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发）

#### poll

- **没有最大连接数的限制**，原因是它是基于链表来存储的.

#### epoll

epoll实际上是**事件驱动（每个事件关联上fd）**（复杂度降低到了O(1)）

所有添加到epoll中的事件都会与设备(网卡)驱动程序建立**回调关系**，这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。

当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。

1. epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。
2. epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。
3. epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。
4. 

### 数据包流转

**封装**: 用户数据->tcp首部->IP首部->以太网首部

通过 **MTU** 切割

**tcp 三次握手**

![](/Users/dawson/project/my_project/C/algorithm/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2.png)

**四次挥手**

![](/Users/dawson/project/my_project/C/algorithm/img/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy.png)

**交换机**

根据帧头的目的MAC地址查找MAC地址表然后将该数据帧从对应端口上转发出去

ARP 请求

**路由器**

路由器根据具体的IP地址来转发数据

**网关**

把所有的IP包发送到一个默认的中转地址上面进行转发，也就是默认网关。这个网关可以在路由器上，可以在三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。



### tcp 传输可靠性

1. **确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。
2. **数据校验**
3. **数据合理分片和排序**：(MTU分片)
4. **流量控制**：当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。
   1. 接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端

5. **拥塞控制**：当网络拥塞时，减少数据的发送。调节客户端接下来的 **发送速率**（sending rate）
   1. BBR 通过**应答包（ACK）中的 RTT 信息**和已发送字节数来计算 **真实传输速率**（delivery rate）
   2. BBR 之前，主流的 TCP 拥塞控制算法都是基于**丢包**（loss-based）设计的

### TCP 协议如何解决粘包、半包问题

1. **固定包长的数据包**
   1. 格式简单但灵活性差。如果包内容不足指定的字节数，剩余的空间需要填充特殊的信息，如 \0
2. **以指定字符（串）为包的结束标志**
   1. 不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。
3. **包头 + 包体格式**

### 7层透明代理

**代理使用 fakeIP 和 源进行握手**

为了实现这个功能, 需要大量的修改

cli <---> proxy <----> srv

一句话就是: 必须让 srv 回来的数据包到 proxy, 因为是和 proxy 握手的

1. socket: setsocketopt, socket的`IP_TRANSPARENT`选项, 需要超级用户权限, 使socket可以接收目的地址没有配置的数据包，也可以发送源地址不是本地地址的数据包实现。使用这种方式，上游服务不需要任何修改就可以得到客户端的ip。
2. srv 必须和 proxy 在一个局域网, 如果出了公网, 返回路径就不能控制了
3. 如果 srv 和 proxy 在一台机器, 设置一下

   1. `iptables -t mangle -A OUTPUT -p tcp --src 172.19.228.32 --sport 15010:15011 -j MARK --set-xmark 0x1/0xffffffff`
   2. `ip route add local 0.0.0.0/0 dev lo table 100`
   3. `ip rule add fwmark 1 lookup 100`
4. 如果不在一台机器, 还需要设置路由

### UNIX Domain Socket 与 TCP/IP Socket 对比

1. UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。
2. UNIX域套接字, 在同一台主机的传输速度是TCP套接字的两倍。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。
3. UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。

### 数据包收发过程

1. 数据帧到达网卡
2. 网卡把桢 DMA 到内存 ring buffer
3. 硬中断通知 cpu
4. cpu 响应硬中断, 简单处理后发出软中断
5. ksoftirqd 进程处理软中断, 调用**网卡驱动注册的函数**收包
6. 从 ring buffer 拿下帧保存为一个 sk_buffer
7. 协议层处理网络帧, 把处理后的数据放入 socket 接收队列

## eBPF

指令**下放到内核中可以带来如下好处**

- **无需在内核/用户空间切换**就可以实现内核的可编程。例如，Cilium 这种和网络相关 的 BPF 程序能直接在内核中实现灵活的容器策略、负载均衡等功能，而无需将包送先 到用户空间，处理之后再送回内核。需要在 **BPF 程序之间或内核/用户空间之间共享状 态**时，可以使用 BPF map。
- **可编程 datapath** 具有很大的灵活性，因此程序能**在编译时将不需要的特性禁用掉， 从而极大地优化程序的性能**。例如，如果容器不需要 IPv4，那编写 BPF 程序时就可以 只处理 IPv6 的情况，从而节省了快速路径（fast path）中的资源。
- 对于网络场景（例如 tc 和 XDP），BPF 程序可以在**无需重启内核、系统服务或容器的 情况下实现原子更新，并且不会导致网络中断**。另外，**更新 BPF map 不会导致程序 状态（program state）的丢失**。
- BPF 给用户空间**提供了一个稳定的 ABI**，而且**不依赖任何第三方内核模块**。BPF 是 Linux 内核的一个核心组成部分，而 Linux 已经得到了广泛的部署，因此可以保证现 有的 BPF 程序能在新的内核版本上继续运行。这种保证与**系统调用**（内核提供给用 户态应用的接口）是同一级别的。另外，BPF 程序**在不同平台上是可移植的**。
- BPF 程序**与内核协同工作**，**复用已有的内核基础设施**（例如驱动、netdevice、 隧道、协议栈和 socket）和工具（例如 iproute2），以及内核提供的安全保证。**和内 核模块不同，BPF 程序会被一个位于内核中的校验器（in-kernel verifier）进行校验， 以确保它们不会造成内核崩溃、程序永远会终止等等**。例如，XDP 程序会复用已有的内 核驱动，能够直接操作存放在 DMA 缓冲区中的数据帧，而不用像某些模型（例如 DPDK） 那样将这些数据帧甚至整个驱动暴露给用户空间。而且，XDP 程序**复用**内核协议栈而 不是绕过它。**BPF 程序可以看做是内核设施之间的通用“胶水代码”**， 基于 BPF 可以设计巧妙的程序，解决特定的问题。

### map

**BPF map 和程序作为内核资源只能通过文件描述符访问，其背后是内核中的匿名 inode**

**文件描述符受限于进程的生命周期，使得 map 共享之类的操作非常笨重**。

**为了解决这个问题，内核实现了一个最小内核空间 BPF 文件系统，BPF map 和 BPF 程序 都可以钉到（pin）这个文件系统内**



### 典型的工作流

1. 用 C 编写 BPF 程序
2. 用 LLVM 将 C 程序编译成对象文件（ELF）
3. 用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件
4. **加载器**通过 `bpf()` 系统调用**将解析后的对象文件注入内核**
5. 内核验证 BPF 指令，然后对其执行即时编译（JIT），**返回程序的一个新文件描述符**
6. 利用文件描述符 **attach 到内核子系统**（例如网络子系统）



## cache 存在的意义

局部性原理

提高命中, 从而加速



## 语言

### cpu指令执行步骤

1. 取指令
2. 指令译码
3. 执行指令
4. 访存取数
5. 结果写回



### 堆区、栈区

1. 栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放
   1. 栈内存分配运算内置于CPU的指令集(SS:SP)，效率很高，但是分配的内存量有限
   2. 栈区是向低地址扩展
2. 堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。
   1. 堆区是向高地址扩展
3. 静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。**程序结束后，由系统释放**。
4. 常量区：常量存储在这里，不允许修改。
   1. cpp 中 静态区和常量区
5. 代码区：顾名思义，存放代码。




### 编译到执行的过程

1. 编译预处理

   1. 宏定义指令
   2. 条件编译指令\# ifdef，# ifndef，# else，# elif，# endi
   3. 头文件包含指令

   总结: 带# 的

2. 编译、优化

   得到汇编代码

3. 汇编

   得到目标文件

4. 链接

   1. 目标文件转化为可执行文件




### overload （重载）

1. 在同一个类中；
2. 函数名字相同；
3. 函数参数不同（类型不同、数量不同，两者满足其一即可）
4. 不以返回值类型不同作为函数重载的条件。

### override （覆盖，子类改写父类的虚函数），用于实现cpp中多态：

1. 分别位于父类和子类中；
2. 子类改写父类中的**virtual**方法；
3. 与父类中的函数原型相同。

### overwrite （重写或叫隐藏，子类改写父类的非虚函数，从而屏蔽父类函数）

1. 与overload类似，但是范围不同，是子类改写父类；
2. 与override类似，但是父类中的方法不是虚函数。



## MySQL

### 事务的特性

- **原子性**（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。

- **一致性**（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。

- **事务隔离**(Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别

  - 未提交读（Read uncommitted）

    **同时读取和修改**

    数据被其他**事务修改过，但还没有提交**，就存在着回滚的可能性，这时候读取这些“未提交”数据的情况就是“**脏读**”。

  - 提交读（read committed）

    **同时读取和修改**

    一个事务能**读取**到其他事务**提交过**(Committed)的数据。

    一个事务在处理过程中如果重复读取某一个数据，而且这个数据恰好被其他事务修改并提交了，那么当前重复读取数据的事务就会出现同一个数据前后不同的情况。

    在这个隔离级别会发生“不可重复读”的场景。

  - 可重复读（repeatable read）

    **同时读取**

    一个事务一旦开始，事务过程中所读取的所有数据不允许被其他事务修改。

    因为它只“保护”了它读取的数据不被修改，但是其他数据会被修改。如果其他数据被修改后恰好满足了当前事务的过滤条件（where语句），那么就会发生“幻影读”的情况。

  - 串行化（Serializable）。

    系统中所有的事务以串行地方式逐个执行，所以能避免所有数据不一致情况。

    但是这种以排他方式来控制并发事务，串行化执行方式会导致事务排队，系统的并发量大幅下降，使用的时候要绝对慎重。

  [事务的隔离级别](https://developer.aliyun.com/article/743691)

- **持久性**（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

### 优化MySQL

1. SQL语句及索引的优化
2. 数据库表结构的优化
3. 系统配置优化
4. 硬件优化



## 红黑树

1. 根结点是黑色
2. 叶子节点是黑色
3. 每个红色节点的两个子节点是黑色
4. 任意一结点到每个叶子结点的路径都包含数量相同的黑结点。